#    "$Name:  $";
#    "$Header:  $";
#=============================================================================
#
# file :        PyElComat.py
#
# description : Python source for the PyElComat and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                PyElComat are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author:  $
#
# $Revision:  $
#
# $Log:  $
#
# copyleft :    Cells / Alba Synchrotron
#               Cerdanyola/Bellaterra
#               Spain
#
#=============================================================================
#          This file is generated by POGO
#    (Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================
#


import PyTango
import sys
import time
import array
import numpy
import threading

#Used for the tables attrs
def flatten(x):
    """from: http://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks
    flatten(sequence) -> list

    Returns a single, flat list which contains all elements retrieved
    from the sequence and all recursively contained sub-sequences
    (iterables).

    Examples:
    >>> [1, 2, [3,4], (5,6)]
    [1, 2, [3, 4], (5, 6)]
    >>> flatten([[[1,2,3], (42,None)], [4,5], [6], 7, MyVector(8,9,10)])
    [1, 2, 3, 42, None, 4, 5, 6, 7, 8, 9, 10]"""

    result = []
    for el in x:
        #if isinstance(el, (list, tuple)):
        if hasattr(el, "__iter__") and not isinstance(el, basestring):
            result.extend(flatten(el))
        else:
            result.append(el)
    return result

#==================================================================
#   PyElComat Class Description:
#
#         Wrapper Device server to access to an elcomat autocollimator, by a PySerialDS bridge
#
#==================================================================
#     Device States Description:
#
#   DevState.INIT : The device is starting the comunication to the PySerialDS
#   DevState.OPEN : The device is well connected to a PySerialDS
#   DevState.CLOSE : The device is NOT connected to the PySerialDS
#   DevState.ON : The instrument is acquiring
#   DevState.OFF : The instrument is NOT acquiring
#   DevState.RUNNING : The device is busy acquiring data from the elcomat
#   DevState.FAULT : Something wrong with the device. Details on the status
#==================================================================

# read the acquired values
#array.array('B',serial.ReadLine()).tostring()
# sample line: '3 003 13.541 -287.714\r' len = 22
#              '3 003 -31.078 -181.899\r' len = 23
# the size of a block is variable!!

class PyElComat(PyTango.Device_4Impl):

#--------- Add you global variables here --------------------------
# Send a command:
#serial.Write(array.array('B',"s\n").tolist())

# commands:
# r : acquire one relative measurement
# a : acquire one absolute measurement
# R : continuous acquisition relative measurements
# A : continuous acquisition absolute measurements
# s : stop continuous acquisition

#PySerialDS configuration:
# Baudrate = 19200
# DataBits = 8
# FlowControl = none
# Parity = none
# Port = if local something like /dev/ttyS0
#        if moxa something like /dev/ttyr00
# StopBits = 1
# Terminator = CR
# Timeout = 0 or 2500

    #@todo: clean the important logs when they loose importance.
    def cleanAllImportantLogs(self):
        self.debug_stream("In %s::cleanAllImportantLogs()"%self.get_name())
        self._important_logs = []
        self.addStatusMsg("")

    def addStatusMsg(self,current,important = False):
        self.debug_stream("In %s::addStatusMsg()"%self.get_name())
        msg = "The device is in %s state.\n"%(self.get_state())
        if not self._serialDevice == None:
            msg = "%sThe PySerial is in %s state.\n"%(msg,self._serialDevice.State())
        for ilog in self._important_logs:
            msg = "%s%s\n"%(msg,ilog)
        status = "%s%s\n"%(msg,current)
        self.set_status(status)
        self.push_change_event('Status',status)
        if important and not current in self._important_logs:
            self._important_logs.append(current)

    def getTimeStamp(self):
        self.debug_stream("In %s::getTimeStamp()"%self.get_name())
        self._timeStamp = time.ctime()
        self.fireEventsList([['TimeStamp',str(self._timeStamp)]])

    def commandInstrument(self,command):
        self.debug_stream("In %s::commandInstrument(%s)"%(self.get_name(),command))
        self._serialDevice.FlushOutput()
        self._serialDevice.Write(array.array('B',command+"\n").tolist())
        self._serialDevice.FlushInput()

    def startInstrument(self):
        self.debug_stream("In %s::startInstrument()"%self.get_name())
        if self._serialDevice == None or not self._serialDevice.State() in [PyTango.DevState.ON]: return
        try:
            if self._measurementType == 'abs': self.commandInstrument('A')
            elif self._measurementType == 'rel': self.commandInstrument('R')
            else:
                self.change_state(PyTango.DevState.FAULT)
                self.addStatusMsg("The type to measure is invalid.")
                raise Exception("Not valid type to measure. It shall be 'abs' or 'rel' (not %s)."%self._measurementType)
        except Exception,e:
            self.warn_stream("In %s::startInstrument() Exception: %s"%(self.get_name(),e))
            self.addStatusMsg("Cannot start the instrument.",important=True)

    def stopInstrument(self):
        self.debug_stream("In %s::stopInstrument()"%self.get_name())
        if self._serialDevice == None or not self._serialDevice.State() in [PyTango.DevState.ON]: return
        try:
            self.commandInstrument("s")
        except Exception,e:
            self.warn_stream("In %s::stopInstrument() Exception: %s"%(self.get_name(),e))
            self.addStatusMsg("Cannot stop the instrument.",important=True)

    def createThread(self):
        self.debug_stream("In %s::createThread()"%self.get_name())
        if not self._serialDevice.State() in [PyTango.DevState.ON]: return False
        if hasattr(self,'_thread') and self._thread and self._thread.isAlive():
            self.debug_stream("In %s::createThread(): Trying to start threading when is already started."%self.get_name())
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Try to start the acquisition thread when is already running.")
            return False
        self.debug_stream("In %s::createThread(): Start acquisition threading."%self.get_name())
        try:
            self._joinerEvent = threading.Event()#to communicate between threads
            self._joinerEvent.clear()
            self._startCmd = threading.Event()#Start command has been received
            self._startCmd.clear()
            self._stopCmd = threading.Event()#Stop command has been received
            self._stopCmd.clear()
            self._thread = threading.Thread(target=self.acqThread)
            self._thread.setDaemon(True)
            self._thread.start()
            self.debug_stream("In %s::createThread(): Thread created."%self.get_name())
        except Exception,e:
            self.warn_stream("In %s::createThread(): Exception creating thread: %s."%(self.get_name(),e))
            return False
        return True

    def deleteThread(self):
        self.debug_stream("In %s::deleteThread(): Stoping acquisition threading."%self.get_name())
        self.stopInstrument()
        if hasattr(self,'_joinerEvent'):
            self.debug_stream("In %s::deleteThread(): sending join event."%self.get_name())
            self._joinerEvent.set()
        if hasattr(self,'_thread'):
            self.debug_stream("In %s::deleteThread(): Thread joining."%self.get_name())
            self._thread.join(1)
            if self._thread.isAlive():
                self.debug_stream("In %s::deleteThread(): Thread joined."%self.get_name())

    def fireEventsList(self,eventsAttrList):
        #self.debug_stream("In %s::fireEventsList()"%self.get_name())
        #@todo: add the value on the push_event

        timestamp = time.time()
        for attrEvent in eventsAttrList:
            try:
                self.debug_stream("In %s::fireEventsList() attribute: %s"%(self.get_name(),attrEvent[0]))
                if len(attrEvent) == 3:#specifies quality
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,attrEvent[2])
                else:
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,PyTango.AttrQuality.ATTR_VALID)
            except Exception,e:
                self.error_stream("In %s::fireEventsList() Exception with attribute %s"%(self.get_name(),attrEvent[0]))
                print e

    def change_state(self,newstate):
        self.debug_stream("In %s::change_state(%s)"%(self.get_name(),str(newstate)))
        self.set_state(newstate)
        self.push_change_event('State',newstate)

    def processBlock(self,ts=False):
        #self.debug_stream("In %s::processBlock()"%self.get_name())
        line = self._serialDevice.ReadLine()#read and clean until a '\r' character
        block = array.array('B',self._serialDevice.Read(65535)).tostring()#read the biggest block possible
        #@todo: add line to the block if it has a well complete line
        if not block == '':
            try:
                lines = block.split('\r')
                lines = lines[:len(lines)-1]#drop the last
                #@todo: only drop if is incomplete
                image = [line.strip().split(' ') for line in lines]
                zimage = zip(*image[:len(image)-1])
                if not len(zimage) == 4:
                    return 0
                #@todo: check if the type of measurement corresponds.
                xx,yy = list(zimage[2]),list(zimage[3])
                for i in range(len(xx)):#same lenght than y
                    xx[i] = float(xx[i])
                    yy[i] = float(yy[i])
                if ts:
                    self._x_ts += xx
                    self._y_ts += yy
                    if (not self._nsamples == 0) and (len(self._x_ts) >= self._nsamples):#cut the exceded
                        self._x_ts = self._x_ts[:self._nsamples]
                        self._y_ts = self._y_ts[:self._nsamples]
                    self.fireEventsList([['Num_samples',len(self._x_ts),PyTango.AttrQuality.ATTR_CHANGING],
                                         ['acqTimer',len(self._x_ts)/float(self.Elcomat_Frequency),PyTango.AttrQuality.ATTR_CHANGING],
                                         ['Table_ts',[self._x_ts,self._y_ts],PyTango.AttrQuality.ATTR_CHANGING],
                                         ['X_ts',self._x_ts,PyTango.AttrQuality.ATTR_CHANGING],
                                         ['Y_ts',self._y_ts,PyTango.AttrQuality.ATTR_CHANGING],
                                         ['Av_x_ts',numpy.mean(self._x_ts),PyTango.AttrQuality.ATTR_CHANGING],
                                         ['Av_y_ts',numpy.mean(self._y_ts),PyTango.AttrQuality.ATTR_CHANGING],
                                         ['Stdv_x_ts',numpy.std(self._x_ts),PyTango.AttrQuality.ATTR_CHANGING],
                                         ['Stdv_y_ts',numpy.std(self._y_ts),PyTango.AttrQuality.ATTR_CHANGING]])
                    return len(xx)
                else:
                    self._x += xx
                    self._y += yy
                    if (not self._nsamples == 0) and (len(self._x) >= self._nsamples):#circle the buffer
                        self._x = self._x[len(self._x)-self._nsamples:]
                        self._y = self._y[len(self._y)-self._nsamples:]
                    self.fireEventsList([['Table',[self._x,self._y]],
                                         ['X',self._x],
                                         ['Y',self._y],
                                         ['Last_x',self._x[len(self._x)-1]],
                                         ['Last_y',self._y[len(self._y)-1]]])
                    return len(xx)
            except Exception,e:
                self.debug_stream("In %s::processBlock() exception with line \"%s\""%(self.get_name(),line))
                print e
        return 0

    def startTsAcq(self):
        self.debug_stream("In %s::startTsAcq()"%self.get_name())
        try:
            collectedSamples = 0
            self._x_ts,self._y_ts = [],[]
            self.getTimeStamp()
            while (collectedSamples <= self._nsamples) and (not self._stopCmd.isSet()):
                collectedSamples += self.processBlock(ts=True)
                time.sleep(0.5)
            self._startCmd.clear()
            self._stopCmd.clear()
            self.fireEventsList([['Table_ts',[self._x_ts,self._y_ts]],
                                 ['X_ts',self._x_ts],
                                 ['Y_ts',self._y_ts],
                                 ['Av_x_ts',numpy.mean(self._x_ts)],
                                 ['Av_y_ts',numpy.mean(self._y_ts)],
                                 ['Stdv_x_ts',numpy.std(self._x_ts)],
                                 ['Stdv_y_ts',numpy.std(self._y_ts)],
                                 ['acqTimer',len(self._x_ts)/float(self.Elcomat_Frequency)],
                                 ['Num_samples',len(self._x_ts)]])
            #clean async data 
            self._x,self._y = [],[]
            self.change_state(PyTango.DevState.ON)
            self.cleanAllImportantLogs()
        except Exception,e:
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Exception in synchronous collection.")
            self.stopInstrument()
            self.debug_stream("In %s::startTsAcq(): Acquisition thread escape (due to exception: %s)."%(self.get_name(),e))

    def acqThread(self):
        self.debug_stream("In %s::acqThread(): Thread started."%self.get_name())
        if not hasattr(self,'_joinerEvent'):
            raise Exception("Not possible to start the loop because it have not end condition")
        failReadCt = 0
        self.startInstrument()
        while not self._joinerEvent.isSet():
            try:
                collectedSamples = self.processBlock()
                #backup_state = self.get_state()#must be ON or RUNNING
                while collectedSamples > 0:
                    failReadCt = 0
                    #if not backup_state == self.get_state():
                    #    self.change_state(backup_state)
                    collectedSamples = self.processBlock()
                    if self._joinerEvent.isSet():
                        break
                    if self._startCmd.isSet():
                        self.startTsAcq()
                    time.sleep(0.25)
                #the buffer is maybe void
                if collectedSamples == 0:
                    self.warn_stream("In %s::acqThread(): void buffer: %s (%d time(s))."%(self.get_name(),collectedSamples,failReadCt+1))
                    failReadCt+=1
                    time.sleep(0.25*failReadCt)
                    if failReadCt == 25:
                        backup_state = self.get_state()
                        self.change_state(PyTango.DevState.ALARM)
                    if failReadCt >= 100:
                        self.change_state(PyTango.DevState.FAULT)
                        msg = "Too many fails reading buffer."
                        self.addStatusMsg(msg)
                        self.error_stream("In %s::acqThread(): Acquisition thread done, due to \"%s\""%(self.get_name(),msg))
                    if self.get_state() == PyTango.DevState.FAULT:
                        return
            except Exception,e:
                self.change_state(PyTango.DevState.FAULT)
                self.addStatusMsg("Exception on collecting loop.")
                self.stopInstrument()
                self.debug_stream("In %s::acqThread(): Acquisition thread escape (due to exception: %s)."%(self.get_name(),e))
                return
        #joinerEvent set
        self.change_state(PyTango.DevState.OPEN)
        self.stopInstrument()
        self.debug_stream("In %s::acqThread(): Acquisition thread done."%self.get_name())

#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        PyElComat.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        self.debug_stream("[Device delete_device method] for device",self.get_name())


#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        self.debug_stream("In ", self.get_name(), "::init_device()")
        self.change_state(PyTango.DevState.INIT)
        self.get_device_properties(self.get_device_class())
        
        self._important_logs = []
        
        try:
            self.PySerialDS = str(self.PySerialDS)
            self.debug_stream("In %s::init_device(): The device server is %s"%(self.get_name(),self.PySerialDS))
        except Exception,e:
            self.warn_stream("In %s::init_device() Exception:%s"%(self.get_name(),e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Exception: Cannot read the property to setup the serial line.")

        try:
            self.Elcomat_Frequency = int(self.Elcomat_Frequency)
            self.debug_stream("In %s::init_device(): The instrument frequency is %s"%(self.get_name(),self.Elcomat_Frequency))
        except Exception,e:
            self.error_stream("In %s::init_device(): Invalid \"Elcomat_Frequency\" "\
                              "property value (or doesn't exist). Setting to default, 25"\
                              %(self.get_name()))
            self.Elcomat_Frequency = 25

        #internal vbles
        self._serialDevice = None
        self._measurementType = 'abs'
        #for the continuous acquisition
        self._x = []
        self._y = []
        #for the snapped acquisition (start() and after running state)
        self._timeStamp = ""
        self._x_ts = []
        self._y_ts = []
        self._nsamples = 25#one second acq.
        self._acqTimer = 1.0

        self.set_change_event('State', True, False)
        self.set_change_event('Status', True, False)

        try:
            #connect to the PySerialDS
            self.Open()
            #set the instrument to start acquisition
            self.On()
        except Exception,e:
            self.error_stream("")
            self.addStatusMsg("Error initializing the communication")

        self.set_change_event('Last_x',True,False)
        self.set_change_event('Last_y',True,False)
        self.set_change_event('X',True,False)
        self.set_change_event('Y',True,False)
        self.set_change_event('Table',True,False)
        self.set_change_event('Av_x_ts',True,False)
        self.set_change_event('Av_y_ts',True,False)
        self.set_change_event('Stdv_x_ts',True,False)
        self.set_change_event('Stdv_y_ts',True,False)
        self.set_change_event('X_ts',True,False)
        self.set_change_event('Y_ts',True,False)
        self.set_change_event('TimeStamp',True,False)
        self.set_change_event('Num_samples',True,False)
        self.set_change_event('acqTimer',True,False)
        self.set_change_event('Table_ts',True,False)

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        pass#self.debug_stream("In %s::always_excuted_hook()"%self.get_name())

#==================================================================
#
#    PyElComat read/write attribute methods
#
#==================================================================
#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        self.debug_stream("In %s::read_attr_hardware()"%self.get_name())



#------------------------------------------------------------------
#    Read Last_x attribute
#------------------------------------------------------------------
    def read_Last_x(self, attr):
        self.debug_stream("In %s::read_Last_x()"%self.get_name())
        
        #    Add your own code here
        
        attr_Last_x_read = self._x[len(self._x)-1]
        attr.set_value(attr_Last_x_read)


#---- Last_x attribute State Machine -----------------
    def is_Last_x_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read Last_y attribute
#------------------------------------------------------------------
    def read_Last_y(self, attr):
        self.debug_stream("In %s::read_Last_y()"%self.get_name())
        
        #    Add your own code here
        
        attr_Last_y_read = self._y[len(self._y)-1]
        attr.set_value(attr_Last_y_read)


#---- Last_y attribute State Machine -----------------
    def is_Last_y_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read Av_x_ts attribute
#------------------------------------------------------------------
    def read_Av_x_ts(self, attr):
        self.debug_stream("In %s::read_Av_x_ts()"%self.get_name())
        
        #    Add your own code here
        
        attr_Av_x_ts_read = numpy.mean(self._x_ts)
        attr.set_value(attr_Av_x_ts_read)


#---- Av_x_ts attribute State Machine -----------------
    def is_Av_x_ts_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read Av_y_ts attribute
#------------------------------------------------------------------
    def read_Av_y_ts(self, attr):
        self.debug_stream("In %s::read_Av_y_ts()"%self.get_name())
        
        #    Add your own code here
        
        attr_Av_y_ts_read = numpy.mean(self._y_ts)
        attr.set_value(attr_Av_y_ts_read)


#---- Av_y_ts attribute State Machine -----------------
    def is_Av_y_ts_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read Stdv_x_ts attribute
#------------------------------------------------------------------
    def read_Stdv_x_ts(self, attr):
        self.debug_stream("In %s::read_Stdv_x_ts()"%self.get_name())
        
        #    Add your own code here
        
        attr_Stdv_x_ts_read = numpy.std(self._x_ts)
        attr.set_value(attr_Stdv_x_ts_read)


#---- Stdv_x_ts attribute State Machine -----------------
    def is_Stdv_x_ts_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read Stdv_y_ts attribute
#------------------------------------------------------------------
    def read_Stdv_y_ts(self, attr):
        self.debug_stream("In %s::read_Stdv_y_ts()"%self.get_name())
        
        #    Add your own code here
        
        attr_Stdv_y_ts_read = numpy.std(self._y_ts)
        attr.set_value(attr_Stdv_y_ts_read)


#---- Stdv_y_ts attribute State Machine -----------------
    def is_Stdv_y_ts_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read TimeStamp attribute
#------------------------------------------------------------------
    def read_TimeStamp(self, attr):
        self.debug_stream("In %s::read_TimeStamp()"%self.get_name())
        
        #    Add your own code here
        
        attr_TimeStamp_read = str(self._timeStamp)
        attr.set_value(attr_TimeStamp_read)


#---- TimeStamp attribute State Machine -----------------
    def is_TimeStamp_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read MeasurementType attribute
#------------------------------------------------------------------
    def read_MeasurementType(self, attr):
        self.debug_stream("In %s::read_MeasurementType()"%self.get_name())
        
        #    Add your own code here
        
        #if self._measurementType == None:
        #    raise Exception("Not valid type to measure. It shall be 'abs' or 'rel'.")
        attr_MeasurementType_read = self._measurementType
        self.debug_stream("In %s::read_MeasurementType(): value = %s"%(self.get_name(),attr_MeasurementType_read))
        attr.set_value(attr_MeasurementType_read)
        if not self._measurementType in ['abs','rel']:
            attr.set_quality(PyTango.AttrQuality.ATTR_INVALID)

#------------------------------------------------------------------
#    Write MeasurementType attribute
#------------------------------------------------------------------
    def write_MeasurementType(self, attr):
        self.debug_stream("In %s::write_MeasurementType()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        data = str(data[0])
        self.debug_stream("Attribute value = ", data)

        #    Add your own code here
        if not data in ['abs','rel']:
            self.error_stream("In %s::write_MeasurementType() trying to write '%s'"%(self.get_name(),data))
            raise Exception("Not valid type to measure. It shall be 'abs' or 'rel'.")
        if not self._measurementType == data:
            self.stopInstrument()
            self._measurementType = str(data)
            self.startInstrument()


#---- MeasurementType attribute State Machine -----------------
    def is_MeasurementType_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.RUNNING]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read Num_samples attribute
#------------------------------------------------------------------
    def read_Num_samples(self, attr):
        self.debug_stream("In %s::read_Num_samples()"%self.get_name())
        
        #    Add your own code here
        
        if not self.get_state() == PyTango.DevState.RUNNING:
            attr.set_value(self._nsamples)
            attr.set_quality(PyTango.AttrQuality.ATTR_VALID)
        else:
            attr.set_value(len(self._x_ts))
            attr.set_quality(PyTango.AttrQuality.ATTR_CHANGING)


#------------------------------------------------------------------
#    Write Num_samples attribute
#------------------------------------------------------------------
    def write_Num_samples(self, attr):
        self.debug_stream("In %s::write_Num_samples()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = ", data)

        #    Add your own code here
        self._nsamples = data[0]
        self._acqTimer = self._nsamples/self.Elcomat_Frequency
        self.fireEventsList([['Num_samples',self._nsamples],
                             ['acqTimer',self._acqTimer]])

#---- Num_samples attribute State Machine -----------------
    def is_Num_samples_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                #PyTango.DevState.OPEN,
                                #PyTango.DevState.CLOSE,
                                #PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read acqTimer attribute
#------------------------------------------------------------------
    def read_acqTimer(self, attr):
        self.debug_stream("In %s::read_acqTimer()"%self.get_name())
        
        #    Add your own code here
        
        if not self.get_state() == PyTango.DevState.RUNNING:
            attr.set_value(self._acqTimer)
            attr.set_quality(PyTango.AttrQuality.ATTR_VALID)
        else:
            attr.set_value(len(self._x_ts)/float(self.Elcomat_Frequency))
            attr.set_quality(PyTango.AttrQuality.ATTR_CHANGING)

#------------------------------------------------------------------
#    Write acqTimer attribute
#------------------------------------------------------------------
    def write_acqTimer(self, attr):
        self.debug_stream("In %s::write_acqTimer()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = ", data)

        #    Add your own code here
        self._acqTimer = data[0]
        self._nsamples = int(self._acqTimer*self.Elcomat_Frequency)
        self.fireEventsList([['acqTimer',self._acqTimer],
                             ['Num_samples',self._nsamples]])

#---- acqTimer attribute State Machine -----------------
    def is_acqTimer_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                #PyTango.DevState.OPEN,
                                #PyTango.DevState.CLOSE,
                                #PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read X attribute
#------------------------------------------------------------------
    def read_X(self, attr):
        self.debug_stream("In %s::read_X()"%self.get_name())
        
        #    Add your own code here
        
        attr_X_read = self._x
        attr.set_value(attr_X_read, len(self._x))


#---- X attribute State Machine -----------------
    def is_X_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read X_ts attribute
#------------------------------------------------------------------
    def read_X_ts(self, attr):
        self.debug_stream("In %s::read_X_ts()"%self.get_name())
        
        #    Add your own code here
        
        attr_X_ts_read = self._x_ts
        attr.set_value(attr_X_ts_read, len(self._x_ts))


#---- X_ts attribute State Machine -----------------
    def is_X_ts_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read Y attribute
#------------------------------------------------------------------
    def read_Y(self, attr):
        self.debug_stream("In %s::read_Y()"%self.get_name())
        
        #    Add your own code here
        
        attr_Y_read = self._y
        attr.set_value(attr_Y_read, len(self._y))


#---- Y attribute State Machine -----------------
    def is_Y_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read Y_ts attribute
#------------------------------------------------------------------
    def read_Y_ts(self, attr):
        self.debug_stream("In %s::read_Y_ts()"%self.get_name())
        
        #    Add your own code here
        
        attr_Y_ts_read = self._y_ts
        attr.set_value(attr_Y_ts_read, len(self._y_ts))


#---- Y_ts attribute State Machine -----------------
    def is_Y_ts_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read Table attribute
#------------------------------------------------------------------
    def read_Table(self, attr):
        self.debug_stream("In %s::read_Table()"%self.get_name())
        
        #    Add your own code here
        
        attr_Table_read = flatten([self._x,self._y])
        attr.set_value(attr_Table_read, len(self._x), 2)


#---- Table attribute State Machine -----------------
    def is_Table_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read Table_ts attribute
#------------------------------------------------------------------
    def read_Table_ts(self, attr):
        self.debug_stream("In %s::read_Table_ts()"%self.get_name())
        
        #    Add your own code here
        
        attr_Table_ts_read = flatten([self._x_ts,self._y_ts])
        attr.set_value(attr_Table_ts_read, len(self._x_ts), 2)


#---- Table_ts attribute State Machine -----------------
    def is_Table_ts_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True



#==================================================================
#
#    PyElComat command methods
#
#==================================================================

#------------------------------------------------------------------
#    Open command:
#
#    Description: 
#------------------------------------------------------------------
    def Open(self):
        self.debug_stream("In %s::Open()"%self.get_name())
        #    Add your own code here
        try:
            self._serialDevice = PyTango.DeviceProxy(self.PySerialDS)
            self._serialDevice.Open()
            self.change_state(PyTango.DevState.OPEN)
            self.cleanAllImportantLogs()
        except:
            self.change_state(PyTango.DevState.CLOSE)
            self.addStatusMsg("Cannot connect to the PySerial device.",important=True)
            return


#---- Open command State Machine -----------------
    def is_Open_allowed(self):
        if self.get_state() in [PyTango.DevState.OPEN,
                                PyTango.DevState.ON,
                                PyTango.DevState.OFF,
                                PyTango.DevState.RUNNING,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Close command:
#
#    Description: 
#------------------------------------------------------------------
    def Close(self):
        self.debug_stream("In %s::Close()"%self.get_name())
        #    Add your own code here
        self._serialDevice.Close()
        self._serialDevice = None
        self.change_state(PyTango.DevState.CLOSE)


#---- Close command State Machine -----------------
    def is_Close_allowed(self):
        if self.get_state() in [PyTango.DevState.CLOSE,
                                PyTango.DevState.ON,
                                PyTango.DevState.RUNNING,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    On command:
#
#    Description: 
#------------------------------------------------------------------
    def On(self):
        self.debug_stream("In %s::On()"%self.get_name())
        #    Add your own code here
        
        try:
            if self.createThread():
                self.change_state(PyTango.DevState.ON)
                self.cleanAllImportantLogs()
        except:
            self.change_state(PyTango.DevState.OFF)
            self.addStatusMsg("Cannot configure properly the instrument")
            return

#---- On command State Machine -----------------
    def is_On_allowed(self):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.ON,
                                PyTango.DevState.RUNNING,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Off command:
#
#    Description: 
#------------------------------------------------------------------
    def Off(self):
        self.debug_stream("In %s::Off()"%self.get_name())
        #    Add your own code here
        self.stopInstrument()
        self.deleteThread()
        self.change_state(PyTango.DevState.OFF)


#---- Off command State Machine -----------------
    def is_Off_allowed(self):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.RUNNING,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Start command:
#
#    Description: 
#------------------------------------------------------------------
    def Start(self):
        self.debug_stream("In %s::Start()"%self.get_name())
        #    Add your own code here
        self._startCmd.set()
        self.change_state(PyTango.DevState.RUNNING)
        self.fireEventsList([['acqTimer',0.0,PyTango.AttrQuality.ATTR_CHANGING],
                             ['Num_samples',0,PyTango.AttrQuality.ATTR_CHANGING],
                             ['Table_ts',[[0],[0]],PyTango.AttrQuality.ATTR_INVALID],
                             ['X_ts',[0],PyTango.AttrQuality.ATTR_INVALID],
                             ['Y_ts',[0],PyTango.AttrQuality.ATTR_INVALID],
                             ['Av_x_ts',0,PyTango.AttrQuality.ATTR_INVALID],
                             ['Av_y_ts',0,PyTango.AttrQuality.ATTR_INVALID],
                             ['Stdv_x_ts',0,PyTango.AttrQuality.ATTR_INVALID],
                             ['Stdv_y_ts',0,PyTango.AttrQuality.ATTR_INVALID]
                             ])
        self.cleanAllImportantLogs()


#---- Start command State Machine -----------------
    def is_Start_allowed(self):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.OFF,
                                PyTango.DevState.RUNNING,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Stop command:
#
#    Description: 
#------------------------------------------------------------------
    def Stop(self):
        self.debug_stream("In %s::Stop()"%self.get_name())
        #    Add your own code here
        self._stopCmd.set()
        self.change_state(PyTango.DevState.ON)


#---- Stop command State Machine -----------------
    def is_Stop_allowed(self):
        if self.get_state() in [PyTango.DevState.INIT,
                                PyTango.DevState.OPEN,
                                PyTango.DevState.CLOSE,
                                PyTango.DevState.ON,
                                PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#==================================================================
#
#    PyElComatClass class definition
#
#==================================================================
class PyElComatClass(PyTango.DeviceClass):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'PySerialDS':
            [PyTango.DevString,
            "Name of the pyserial device who is connected to the serial port where the elcomat is",
            [] ],
        'Elcomat_Frequency':
            [PyTango.DevUShort,
             "Number of samples per second that the instruments aquires.",
             [] ],
        }


    #    Command definitions
    cmd_list = {
        'Open':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Close':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'On':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Off':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Start':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Stop':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        }


    #    Attribute definitions
    attr_list = {
        'Last_x':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label':"last_x",
                'unit':"arcsec",
                'description':"Last measured value for X angle",
            } ],
        'Last_y':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label':"last_y",
                'unit':"arcsec",
                'description':"Last measured value for Y angle",
            } ],
        'Av_x_ts':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label':"Av_x",
                'unit':"arcsec",
                'description':"Average of the timestamped measured on X angle",
            } ],
        'Av_y_ts':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label':"Av_y",
                'unit':"arcsec",
                'description':"Average of the timestamped measured on Y angle",
            } ],
        'Stdv_x_ts':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label':"std_x",
                'unit':"arcsec",
                'description':"Standard deviation of the timestamped measured on X angle",
            } ],
        'Stdv_y_ts':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label':"std_y",
                'unit':"arcsec",
                'description':"Standard deviation of the timestamped measured on Y angle",
            } ],
        'TimeStamp':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label':"Time Stamp",
                'description':"The time stamp from the start of the last acquisition",
            } ],
        'MeasurementType':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"Measurement Type",
                'description':"'abs' for absolute measurements or 'rel' for relative measurements",
                'Memorized':"true",#"true_without_hard_applied",
            } ],
        'Num_samples':
            [[PyTango.DevULong,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"Number of samples",
                'description':"Number of values collected in a measurement",
            } ],
        'acqTimer':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"acquisition timer",
                'unit':"seconds",
                'description':"Set the time to collect, and read the time collected.",
            } ],
        'X':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ, 100000],
            {
                'label':"X",
                'unit':"arcsec",
                'description':"Measured values for X angle",
            } ],
        'X_ts':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ, 100000],
            {
                'label':"X",
                'unit':"arcsec",
                'description':"Measured values for X angle, related with the timestamped acquisition",
            } ],
        'Y':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ, 100000],
            {
                'label':"Y",
                'unit':"arcsec",
                'description':"Measured values for Y angle",
            } ],
        'Y_ts':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ, 100000],
            {
                'label':"Y",
                'unit':"arcsec",
                'description':"Measured values for Y angle, related with the timestamped acquisition",
            } ],
        'Table':
            [[PyTango.DevDouble,
            PyTango.IMAGE,
            PyTango.READ, 100000, 100000]],
        'Table_ts':
            [[PyTango.DevDouble,
            PyTango.IMAGE,
            PyTango.READ, 100000, 100000]],
        }


#------------------------------------------------------------------
#    PyElComatClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name);
        print "In PyElComatClass  constructor"

#==================================================================
#
#    PyElComat class main method
#
#==================================================================
if __name__ == '__main__':
    try:
        py = PyTango.Util(sys.argv)
        py.add_TgClass(PyElComatClass,PyElComat,'PyElComat')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e
